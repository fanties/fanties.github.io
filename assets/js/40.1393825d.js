(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{400:function(t,a,v){"use strict";v.r(a);var r=v(0),_=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("很多设计模式其实在一些优秀的框架中都是混合使用的。")])]),t._v(" "),a("h3",{attrs:{id:"策略模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[t._v("#")]),t._v(" 策略模式：")]),t._v(" "),a("p",[t._v("策略模式是对算法的封装。定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换")]),t._v(" "),a("p",[t._v("优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。")]),t._v(" "),a("p",[t._v("缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。")]),t._v(" "),a("p",[t._v("场景：")]),t._v(" "),a("p",[t._v("Spring中Aop代理策略createAopProxy(下文讲解)\nSpring的对象实例化策略InstantiationStrategy")]),t._v(" "),a("h3",{attrs:{id:"委派模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#委派模式"}},[t._v("#")]),t._v(" 委派模式：")]),t._v(" "),a("p",[t._v("委派模式的基本作用就是负责任务的调度和分配任务")]),t._v(" "),a("p",[t._v("场景：")]),t._v(" "),a("p",[t._v("类加载的双亲委派机制\nSpringMVC的DispatcherServlet\nSpring中bean解析的BeanDefinitionParserDelegate")]),t._v(" "),a("h3",{attrs:{id:"代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[t._v("#")]),t._v(" 代理模式：")]),t._v(" "),a("p",[t._v("代理模式为其他对象提供一种代理以控制对这个对象的访问")]),t._v(" "),a("p",[t._v("优点： 1、职责清晰。 2、高扩展性。 3、智能化。")]),t._v(" "),a("p",[t._v("缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。")]),t._v(" "),a("p",[t._v("场景：")]),t._v(" "),a("p",[t._v("JDK动态代理和CGLIB动态代理\nSpring的AOP")]),t._v(" "),a("h3",{attrs:{id:"代理和策略的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理和策略的区别"}},[t._v("#")]),t._v(" 代理和策略的区别")]),t._v(" "),a("p",[t._v("代理是完全和具体实现有相同的接口。在一次处理中的一系列调用，往往都是使用的同一个实现类处理。")]),t._v(" "),a("p",[t._v("策略实际上只是只是对某个接口，下面有多重实现方案，他们的功能是一样的，只不过算法不同，每次调用都会根据情况来选择一冲合适的策略执行。")]),t._v(" "),a("h3",{attrs:{id:"代理和委派"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理和委派"}},[t._v("#")]),t._v(" 代理和委派")]),t._v(" "),a("ul",[a("li",[t._v("委派模式的基本目的就是负责任务的调用和分配，和代理模式很像，可以看成是一个特殊的静态代理的全权代理")]),t._v(" "),a("li",[t._v("但是代理模式注重过程()，委派模式注重结果(老板不关注任务是怎么完成的，只管把任务交给经理让他去委派调度)。")]),t._v(" "),a("li",[t._v("代理模式中，代理类的被代理对象始终不变，而委派模式中委派类的被委托对象可以随时切换。")]),t._v(" "),a("li",[t._v("委派模式中委派类相当于全权代理，而不是像代理模式是部分代理")]),t._v(" "),a("li",[t._v("也有人理解为代理模式中二者是上下级关系，而委派模式中二者是平级关系")])]),t._v(" "),a("h3",{attrs:{id:"委派和策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#委派和策略"}},[t._v("#")]),t._v(" 委派和策略：")]),t._v(" "),a("p",[t._v("委派往往是分派任务，这些任务往往并不是实现同一个功能\n策略模式是选择策略，这些策略实现同一个功能，只是算法不同。")]),t._v(" "),a("h3",{attrs:{id:"经验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#经验"}},[t._v("#")]),t._v(" 经验")]),t._v(" "),a("p",[t._v("要真正理解并掌握他们，完全抽象理解是不可行的。\n我们需要阅读大量的代码，学习别人的设计实现，然后进行总结，才可以更加理解。\n同样的，要掌握好，还需要我们亲自设计，编写大量的代码，不断的重构、优化，设计，总结，就能对此有更加深刻的理解，甚至是自己的一套经验。")]),t._v(" "),a("h3",{attrs:{id:"案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[t._v("#")]),t._v(" 案例")]),t._v(" "),a("p",[t._v("Spring中的DispatcherServlet\nDispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。这体现了委派模式。")]),t._v(" "),a("p",[t._v("而在DispatcherServlet中，又通过策略模式对流程每一部分选择具体的实现。")]),t._v(" "),a("p",[t._v("所以在实际开发中，往往都是多种设计模式的混合体运用。")]),t._v(" "),a("h3",{attrs:{id:"参考文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/qq_37141773/article/details/100561553",target:"_blank",rel:"noopener noreferrer"}},[t._v("【设计模式】——代理、策略、委派模式还在傻傻分不清？"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=_.exports}}]);