(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{378:function(t,_,e){"use strict";e.r(_);var v=e(0),a=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("blockquote",[_("p",[t._v("引言:\n使用JWT时，有一个十分头疼问题就是：用户主动注销、强制登出(禁止登陆)、忘记密码、修改密码、JWT续签、踢出下线时，服务器不能让token主动失效！")])]),t._v(" "),_("p",[t._v("本文将探索关于这个问题的解决方案。")]),t._v(" "),_("h3",{attrs:{id:"目录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录：")]),t._v(" "),_("p",[t._v("[toc]")]),t._v(" "),_("ol",[_("li",[t._v("什么是JWT")]),t._v(" "),_("li",[t._v("JWT的特点")]),t._v(" "),_("li",[t._v("JWT主动失效方案")]),t._v(" "),_("li",[t._v("JWT主动失效最佳实践")]),t._v(" "),_("li",[t._v("进阶优化")]),t._v(" "),_("li",[t._v("总结")])]),t._v(" "),_("h3",{attrs:{id:"_1-什么是jwt"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是jwt"}},[t._v("#")]),t._v(" 1.什么是JWT")]),t._v(" "),_("blockquote",[_("p",[t._v("JWT(JSON Web Token)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。")])]),t._v(" "),_("h3",{attrs:{id:"_2-jwt的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-jwt的特点"}},[t._v("#")]),t._v(" 2.JWT的特点")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("无状态：\nJWT包含认证信息，token只需要保存在客户端，服务端不需要保存会话信息，所以JWT是无状态的。\n这一点使得服务器压力大大降低，增加了系统的可用性和可扩展性。\n但是无状态同时也是JWT最大的缺点，服务器无法主动让token失效。")])]),t._v(" "),_("li",[_("p",[t._v("安全性：客户端每次请求都会携带token，可以有效避免CSRF攻击，同时token会自动过期，可以减少token被盗用的情况，服务器会通过jwt签名验证token，可以避免token被篡改。")])]),t._v(" "),_("li",[_("p",[t._v("可见性：\nJWT的payload部分可以直接通过Base64解码，所以可存储一些其他业务逻辑所必要的非敏感信息。")])])]),t._v(" "),_("h3",{attrs:{id:"_3-jwt主动失效方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-jwt主动失效方案"}},[t._v("#")]),t._v(" 3.JWT主动失效方案")]),t._v(" "),_("p",[t._v("由JWT的特点可知，JWT是无状态的，并且JWT的过期时间是签发的时候确定的，无法动态修改，\n所以服务端如何让JWT主动失效成为了一个问题。\n下面是几种让JWT主动失效的方案")]),t._v(" "),_("ol",[_("li",[t._v("服务器生成token时，将每一个token都保存在Redis中，每次请求都会直接对比用户携带的token和redis中的token，如果token相同，则通过验证，否则判定为token失效。")]),t._v(" "),_("li",[t._v("版本号校验：token和redis中保存用户的token版本号，每次请求对比版本号，一致就通过，不一致就拒绝，主动失效时直接使redis中该用户token版本号+1.")]),t._v(" "),_("li",[t._v("服务端保存一个token黑名单，服务器将需要失效的token放入黑名单，每次请求判断携带的token是否在黑名单之中。")]),t._v(" "),_("li",[t._v("redis保存主动过期时间，每次请求获取token的签发时间，和redis中的过期时间对比，小于过期时间则失效。")]),t._v(" "),_("li",[t._v("签名校验，数据库中每个用户保存一个token签名，签发token时携带签名信息，redis中保存过期签名信息黑名单。每次比对签名，在黑名单，则失效。")])]),t._v(" "),_("h3",{attrs:{id:"_4-jwt主动失效最佳实践"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-jwt主动失效最佳实践"}},[t._v("#")]),t._v(" 4.JWT主动失效最佳实践")]),t._v(" "),_("p",[t._v("通过了解上面的JWT主动失效方案，下面结合实际业务需求，\n总结一种可以应用于生产的最佳实践方案:")]),t._v(" "),_("ol",[_("li",[t._v("首先保证token过期时间不要太长，一般120分钟比较合适。")]),t._v(" "),_("li",[t._v("token必须携带签发时间")]),t._v(" "),_("li",[t._v("通过redis保存一个黑名单，key包含用户id，value为主动失效时间戳。")]),t._v(" "),_("li",[t._v("每次请求，通过token基本校验之后，查询黑名单中是否有该用户id,如果有，那么比较token签发时间和黑名单中的主动失效时间，如果签发时间早于失效时间，那么表示token失效，拒绝请求，否则允许访问。")])]),t._v(" "),_("h4",{attrs:{id:"关于黑名单的实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于黑名单的实现"}},[t._v("#")]),t._v(" 关于黑名单的实现：")]),t._v(" "),_("p",[t._v("可以直接使用redis保存key-value,key中携带用户id，value为失效时间，这样的话就可以直接使用redis的自动过期，这个过期时间设置为token有效时长(如前面的120分钟)")]),t._v(" "),_("h4",{attrs:{id:"实现主动失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现主动失效"}},[t._v("#")]),t._v(" 实现主动失效：")]),t._v(" "),_("p",[t._v("当需要主动让某用户token失效时，\n可以组合当前用户id和当前时间戳保存在redis中，并设置有效时长。")]),t._v(" "),_("h3",{attrs:{id:"_5-进阶"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-进阶"}},[t._v("#")]),t._v(" 5.进阶")]),t._v(" "),_("p",[t._v("对于上面这种方案，\n每次让用户token失效，则会使得该用户在失效前签发的所有token都失效，无法更加精确的控制token的失效性。")]),t._v(" "),_("h4",{attrs:{id:"优化1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化1"}},[t._v("#")]),t._v(" 优化1：")]),t._v(" "),_("p",[t._v("如果实际需求是，有多个应用产品，比如Android、IOS、Windows和Web多端产品，业务要求可以每次控制失效的具体是哪个产品申请的token。")]),t._v(" "),_("p",[t._v("这种情况，我们可以在JWT的payload中保存一个请求签发的token的具体客户端应用标识，比如(android)，\n而redis过期黑名单中的key值，除了携带用户id，再加上具体想失效的应用标识即可。")]),t._v(" "),_("p",[t._v("当然，如果要具体到每一个token，只能采用上面的方案1了。")]),t._v(" "),_("h4",{attrs:{id:"优化2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化2"}},[t._v("#")]),t._v(" 优化2：")]),t._v(" "),_("p",[t._v("如果实际应用对访问速度和性能要求比较高，用户每次请求都要连接redis读取信息，是比较浪费的。\n实际上，redis作为内存数据库，其速度已经相当的快了，不过实际场景可能会是分布式缓存系统，redis连接和读取还是会有一定的ttl延迟。\n优化办法就是：需要做JWT校验的服务器应用，在启动时，访问分布式缓存中的token过期黑名单，将其保存在应用的本地内存当中。同时订阅分布式缓存的消息推送，在黑名单信息发生变化是，进行数据同步。")]),t._v(" "),_("h3",{attrs:{id:"_6-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-总结"}},[t._v("#")]),t._v(" 6.总结")]),t._v(" "),_("p",[t._v("通过上面的解决方案实践和优化\n我们就可以实现服务器端主动让token失效的功能了。\n而在具体的应用场景有：")]),t._v(" "),_("blockquote",[_("p",[t._v("用户主动注销、强制登出(禁止登陆)、忘记密码、修改密码、JWT续签、踢出下线等")])]),t._v(" "),_("p",[t._v("实现的代价就是需要使用redis缓存黑名单，\n在一定程度上破坏了JWT无状态的特性，\n但是实际上需要主动使JWT失效的情况只占整个活动用户的很小一部分，\n所以相比较于分布式Session，JWT实现的方式需要的存储空间很小。")]),t._v(" "),_("p",[t._v("对于进阶优化2，使用了分布式缓存和应用本地同步，增加了方案的复杂性，\n不过对于大部分的应用场景来说，都具有完整的分布式缓存、消息分布订阅组件，只需要直接使用现成的即可，花费的代价并不多。")]),t._v(" "),_("blockquote",[_("p",[t._v("究竟采用哪种方案实现，都应该结合具体的业务需求的，并不存在真正完美的方案。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);